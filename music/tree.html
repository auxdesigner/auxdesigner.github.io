<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>水墨画</title>
    <style>
      html {
        overflow: hidden;
        touch-action: none;
        content-zooming: none;
      }
      body {
        position: absolute;
        margin: 0;
        padding: 0;
        background: #111;
        width: 100%;
        height: 100%;
      }
      #canvas {
        width: 100%;
        height: 100%;
        background: #fff;
        position: absolute;
      }
      audio {
        position: fixed;
        right: 0px;
        z-index: 2;
      }
    </style>
  </head>

  <body>
    <audio id="audio" src="./demo.mp3" controls></audio>

    <canvas id="canvas" width="1263" height="796"></canvas>

    <script>
      (function () {
        audio.onplay = function (event) {
          var audio = document.getElementById("audio");
          var controller = audio.controller;
          var context = new AudioContext();
          var src = context.createMediaElementSource(audio);
          var analyser = context.createAnalyser();
          src.connect(analyser);
          analyser.connect(context.destination);

          analyser.fftSize = 512;
          var bufferLength = analyser.frequencyBinCount;
          var dataArray = new Uint8Array(bufferLength);
          console.log(dataArray);

          function parse() {
            analyser.getByteFrequencyData(dataArray);

            var lowerHalfArray = dataArray.slice(0, dataArray.length / 2 - 1);
            var upperHalfArray = dataArray.slice(
              dataArray.length / 2 - 1,
              dataArray.length - 1
            );

            var overallAvg = avg(dataArray);
            var lowerMax = max(lowerHalfArray);
            var lowerAvg = avg(lowerHalfArray);
            var upperMax = max(upperHalfArray);
            var upperAvg = avg(upperHalfArray);

            var lowerMaxFr = lowerMax / lowerHalfArray.length;
            var lowerAvgFr = lowerAvg / lowerHalfArray.length;
            var upperMaxFr = upperMax / upperHalfArray.length;
            var upperAvgFr = upperAvg / upperHalfArray.length;

            console.log(overallAvg);

            requestAnimationFrame(parse);
          }

          parse();
        };

        audio.onpause = function () {};

        function avg(arr) {
          var total = arr.reduce(function (sum, b) {
            return sum + b;
          });
          return total / arr.length;
        }

        function max(arr) {
          return arr.reduce(function (a, b) {
            return Math.max(a, b);
          });
        }

        // branch constructor

        function Branch(parent, level, x, y) {
          this.parent = parent;
          this.branches = [];
          this.p0 = parent ? parent.p1 : new Point(x, y);
          this.p1 = new Point(x, y);
          this.level = level;
          this.life = 20;
          this.angle = 0;
          this.vx = 0;
          this.vy = 0;
        }

        // grow branch

        Branch.prototype.grow = function () {
          // recursively grow children branches

          for (var i = 0; i < this.branches.length; i++) {
            this.branches[i].grow();
          }

          // grow branch

          if (this.life > 1) {
            this.p1.x += this.vx;
            this.p1.y += this.vy;

            ctx.beginPath();
            ctx.lineCap = "round";

            if (this.level) {
              // draw branch

              ctx.lineWidth = this.level * 6 - 5;
              ctx.strokeStyle = "#000";

              if (this.parent) {
                ctx.moveTo(this.parent.p0.x, this.parent.p0.y);
                ctx.quadraticCurveTo(
                  this.p0.x,
                  this.p0.y,
                  this.p1.x,
                  this.p1.y
                );
              }

              ctx.stroke();
            } else {
              // draw leaf
              var colors = ["#ff003b", "#ff4400", "#ffc300"];

              ctx.lineWidth = 10;
              ctx.strokeStyle =
                colors[Math.floor(Math.random() * colors.length)];
              ctx.moveTo(this.p0.x, this.p0.y);
              ctx.lineTo(this.p1.x, this.p1.y);
              ctx.stroke();
            }
          }

          // create sub branches

          if (this.life === 1 && this.level > 0 && this.level < maxLevels) {
            this.branches.push(newBranch(this));
            this.branches.push(newBranch(this));
          }

          // decrement branch life

          this.life--;
        };

        // point 2D constructor

        function Point(x, y) {
          this.x = x;
          this.y = y;
        }

        // new branch factory

        function newBranch(parent) {
          var branch = new Branch(
            parent,
            parent.level - 1,
            parent.p1.x,
            parent.p1.y
          );

          branch.angle =
            autorun && parent.level === maxLevels
              ? Math.random() * 2 * Math.PI
              : Math.atan2(
                  parent.p1.y - parent.p0.y,
                  parent.p1.x - parent.p0.x
                ) +
                (Math.random() * 1.4 - 0.7);

          branch.vx = Math.cos(branch.angle) * 12;
          branch.vy = Math.sin(branch.angle) * 12;

          branch.life =
            branch.level === 1
              ? 5
              : Math.round(Math.random() * (branch.level * 2)) + 2;

          return branch;
        }

        // main animation loop

        function run() {
          // request next frame

          requestAnimationFrame(run);

          // clear screen (with a bit of magic)
          function clear() {
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = "rgba(255,255,255,0.01)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = "source-over";
          }

          if (++frame % 2) {
            clear();
          }

          // follow the pointer

          current.p1.x = canvas.width * 0.5;
          current.p1.y = canvas.height * 0.5;

          // grow tree

          root.grow();

          // create trunk branches

          if (autorun && Math.random() > 0.8) {
            var branch = new Branch(
              current,
              current.level,
              current.p1.x,
              current.p1.y
            );
            current.branches.push(branch);

            if (Math.random() > 0.8) current.branches.push(newBranch(current));

            current = branch;
            nBranches++;
          }

          // cut the tree

          if (nBranches > maxBranches) {
            root = root.branches[0];
            nBranches--;
          }
        }

        // prepare the canvas

        var canvas = {
          elem: document.getElementById("canvas"),
          width: 0,
          height: 0,
          resize: function () {
            this.width = this.elem.width = this.elem.offsetWidth;
            this.height = this.elem.height = this.elem.offsetHeight;
          },
        };

        var ctx = canvas.elem.getContext("2d");

        window.addEventListener("resize", canvas.resize.bind(canvas), false);
        canvas.resize();

        // variables

        var maxLevels = 7;
        var nBranches = 0;
        var maxBranches = 200;
        var autorun = true;
        var frame = 0;
        var root = new Branch(
          false,
          maxLevels,
          canvas.width * 0.5,
          canvas.height * 0.5
        );
        var current = root;

        // start

        run();
      })();
    </script>
  </body>
</html>
